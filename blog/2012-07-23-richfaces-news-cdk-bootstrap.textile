---
title: "News about RichFaces CDK and Bootstrap"
authors: [pauldijou]
layout: post
summary: 0
tags: [en, fr, richfaces, cdk, bootstrap]
---
h3. Table of Content
# "English version":#en
## "RichFaces Bootstrap":#en-bootstrap
## "RichFaces CDK":#en-cdk
## "RichFaces.Future":#en-future
# "Version Francaise":#fr
## "RichFaces Bootstrap":#fr-bootstrap
## "RichFaces CDK":#fr-cdk
## "RichFaces.Futur":#fr-futur

h3(#en). English Version

div(alert alert-error). *Red Alert!* The RichFaces Bootstrap project is still under heavy development, tag and attribute names can change at any time and if you find something missing or buggy, there is high chance it's not a bug but just hasn't been done yet (... or it's a real bug). So only use it for fun and prototype purposes.

Over the last few weeks, a lot of work has been done on the Sandbox project "RichFaces Bootstrap":https://github.com/richfaces/sandbox/tree/develop/bootstrap. In order to achieve all new requirements and to have a cleaner code, the "RichFaces CDK":https://github.com/richfaces/cdk has also been improved at the same time. Let's review all that new stuff!

h3(#en-bootstrap). What's new in RichFaces Bootstrap?

Good question! So first, we've got a few new components including a *modal* panel, *tooltip* and *popover* for displaying messages onmouseover, and the *input* tag with all Bootstrap features like prepend and append and several new attributes in order to support new HTML features. By the way, this *input* centralizes and supports all HTML5 input types, you will no longer need one JSF component for each type, just use the <code>type</code> attribute (default is "text" of course).

div(alert alert-info). *Pro tip* If you have a modal like <code>b:modal id="myModal"</code>, you might want to update its content using Ajax with something like <code>f:ajax render="myModal"</code>. But that code will render the whole modal, and subsequently hide it since it was hidden by default and waiting for a user interaction to appear. Most of the time, what you really wanted was to render only the content of the modal and keep it displayed. Using the RichFaces Bootstrap modal component, just write <code>f:ajax render="myModalContent"</code>, adding the *Content* suffix right after the id of your modal, and it will render only the content of the modal.

The *tabbable* component now allows you to choose which tab should be displayed by default. You've got 3 ways to do that. First, set <code>default="true"</code> on a *tabPane* and it will be the default one. If several *tabPane* got that attribute to true, the first one will be the winner. Next, you can set a name to your *tabPane* using the <code>name</code> attribute and then, use the <code>activeName</code> to specify which name to display. Finally, each tab has an index, starting at 0, so you can use <code>activeIndex</code> attribute to specify which tab to display. But wait, Bootstrap tabbable supports "nested" tabs. Well, they are not really nested in each other but they are on the navbar of the tabbable. The <code>activeIndex</code> supports this notion of nesting. For example, the index "1.0.2" will display the 3rd tab of the 1st group of the 2nd group inside the tabbable. The default index separtor is <code>.</code> (dot) but you can override it by using <code>indexSeparator</code> attribute.

div(alert). *Warning* If you look at the source code right now, you will see that the first index for *activeIndex* is 1 and not 0. I will change it soon to 0 in order to be more coherent with Array and Collection indexing in Java even if it's less human readable.

h3(#en-cdk). RichFaces CDK new features

As the RichFaces Bootstrap project grows, we need more tools to achieve new goals and keep the code clean and readable. More tools means a stronger CDK and here are the last features.

*Fragments* are small portions of code inside the template that are defined outside of the main implementation but can be called inside it or inside other fragments or even inside itself! Say hello to recursion in RichFaces CDK templates. In term of Java, fragments are methods. So when you write a fragment, it will generates a Java method in the final renderer. Knowing that makes fragments really easy to understand and to use. See the "JIRA issue 12226":https://issues.jboss.org/browse/RF-12226 for a fully explained example.

div(alert alert-info). *Pro tip* Notice that in the signature of the generated Java method, 3 arguments are always passed without having to specify them inside the template : ResponseWriter, FacesContext and UIComponent.

div(alert). *Warning* Currently, if you want to use a fragment1 inside a fragment2, you need to write fragment1 first in your template so it's signature has been parsed before calling it in fragment2.

*Semantic components* are a brand new concept. Most of the time, for one JSF tag, you have one and only one renderer, it's a oneToOne relation (according to JSF naming convention). It seems logical: for one component, you should always have (nearly) the same generated HTML code. But with HTML5, the web is becoming a little bit more semantic and that's good. Why not have the same with RichFaces? But before we dive into it, what is semantic? For a real definition see "Wikipedia":http://en.wikipedia.org/wiki/Semantic_Web but here, we will say it's when a component serve a global purpose like being a header or a footer but shouldn't always render in the same way, instead the rendered result should depend on the context (like a table header isn't the same as a column header).

With RichFaces, a semantic component is a component *with no renderer*! Yeah yeah, if you use a semantic component on its own, it will throw an exception because it doesn't know how to render itself. The concept is that a semantic component will ask it's parent in the JSF tree: "Hey dad, do you know how I can render myself?", if it know, the parent will provide the correct renderer to the semantic component which will render it, otherwise, the semantic component will ask one level higher the same question, and so on until the root element. If no one answer yes to the question, it will throw an exception. That means we also have components that accept semantic components in order to provide them the correct renderer.

Let's take a concrete example. The *modal* component in RichFaces Bootstrap can support 3 semantic components: a header, a body and a footer. You can see that by looking at which interfaces the <code>AbstractModal</code> implements (see "GitHub":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java#L49). All interfaces with the syntax <code>Render{1}Capable</code> means that this component supports the semantic component <code>{1}</code>, so here, it's *headerGroup*, *bodyGroup* and *footerGroup*. And if you look at the rest of the code of the <code>AbstractModal</code>, you will see methods with the syntax <code>public String get{1}RendererType()</code> which are the methods giving the right renderer to use by semantic components. Inside a *modal*, the *headerGroup* component will render as a <code>div class="modal-header"</code> according to "the renderer provided":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/templates/org/richfaces/bootstrap/modalHeaderGroup.template.xml by the *modal*. But inside another component, it could have been totally different HTML code.

div(alert alert-info). *Pro tip* If you take a more accurate look to all current semantic components, you will see that they all follow the same syntax: first their purpose (like *header* or *footer*) and then a generic *Group* suffix. That give us the full list of semantic components: headerGroup, bodyGroup, footerGroup, menuGroup and positionGroup. Why using a suffix? Because we want to keep the no-suffix name for the real HTML tag. The RichFaces *header* tag will always generate the HTML *header* tag like a classic JSF tag (the oneToOne relation) but the *headerGoup* tag is a semantic component so it can generate anything depending of the context. Also, it makes it easier to see if a RichFaces component is a semantic one or not.

div(alert). *Warning* Right now the suffix is *Group* but according to the last team meeting, it will be changed to *Facet*. The first choice was to go according to the JSF core *panelGroup* component. But finally, we see semantic components more like JSF facets than grouping. But keep in mind that semantic components *are not *facets*, they don't have the same limitations: you can use the same semantic component several time inside the same parent, a semantic component doesn't have to be a direct child of a component supporting it and a semantic component can have several children.

*cdk:renderFacet* is a new tag you can use inside a CDK template. Its usage is quite straightforward: it will render the facet that you will specify in the <code>name</code> attribute. If you put some content inside the tag, it will be used as default value in case the facet is missing. See the "JIRA issue 12260":https://issues.jboss.org/browse/RF-12260 for full description.

*varStatus* is a new attribute for the *c:forEach* CDK tag. It will perform the exact same thing as the one in the original *c:forEach* tag, giving you more tools inside a forEach loop. See "JIRA issue 12232":https://issues.jboss.org/browse/RF-12232

*wildcard* can now be used inside *cdk:passThrough* attribute in order to pass all attributes starting with the same prefix. Especially useful with JavaScript events <code>on*</code>. See "JIRA issue 12200":https://issues.jboss.org/browse/RF-12200

h3(#en-future). What's coming?

Want more? Great, because we have tons of other plans to improve RichFaces!

*LESS support* is no longer a dream (for those who doesn't know LESS, it's a more powerful way to write CSS, see the "project website":http://lesscss.org/ for more infos). Thanks to Lukas' awesome work, a first prototype of that feature is already working. Take a look at "that video":TODO Vimeo link to have a preview. There is still work to do but it's an incredible starting point.

*jQuery UI* is approaching. Even if Bootstrap is a good framework to build new components, it's not the only one at all, jQuery UI is another famous one using the jQuery library which is already present in RichFaces. Brian just pushed a first RichFaces component on the Sandbox repo, an "orderingList":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/templates/org/richfaces/bootstrap/orderingList.template.xml. If you know cool jQuery UI widget that should be used in RichFaces, feel free to suggest them "here":https://community.jboss.org/thread/200343?tstart=0.

*New build design* is currently under "discussion on RichFaces wiki":https://community.jboss.org/wiki/RichFaces43BuildRedesign so be sure to take a look and give feedback if you care about the future of RichFaces.

h3(#fr). Version Francaise

h3(#fr-bootstrap). Quoi de neuf au sein de RichFaces Bootstrap ?

h3(#fr-cdk). Les nouvelles fonctionnalités du CDK RichFaces

h3(#fr-futur). Qu'avons nous en approche ?